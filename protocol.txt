CASIO Ex-Word プロトコルドキュメント
====================================

Casio EX-Word 電子辞書が使うプロトコルは、標準 OBEX の修正版です。
このカスタム実装では、各リクエストの先頭にシーケンス番号が付きます。
レスポンスはリクエストのシーケンス番号を含む1バイトのパケットに続いて返されます。

リクエスト/レスポンスの例
request:   <seq> <opcode> <packet length> <headers...>
response:  <seq>
           <response code> <response length> <headers...>

List of commands:

Connect
  このコマンドは最初に送る必要があり、辞書上の OBEX サーバへ接続します。

  リクエスト/レスポンスは標準 OBEX と同様ですが、リクエストのバージョンバイトが動作モードを示し、
  さらに 0x40, 0x00 と地域を示す1バイトの合計3バイトが追加されます。

  有効な地域コード:
     Japanese = 0x20
     Korean   = 0x40
     Chinese  = 0x60
     German   = 0x80
     Spanish  = 0xa0
     French   = 0xc0
     Russian  = 0xe0

  モード:
     TextLoader = <region>
     Library    = <region> - 0xf
     CDLoader   = 0xf0

Disconnect
  ディクショナリへ disconnect を送り、USB デバイスを終了します。
  標準の OBEX disconnect opcode を使用し、追加ヘッダはありません。

Setpath
  デバイスのカレントパスを変更します。

  パスは /_INTERNAL_00 または /_SD_00 で始め、内部メモリか挿入中の SD カードを指定します。

  Request:
    0x85 (setpath) opcode を使い、name ヘッダに Unicode パス名を含めます。
  Response:
    追加ヘッダはありません。

Capacity
  現在選択されている記憶デバイスの容量を取得します。

  Request:
    0x83 (get) opcode を使い、name ヘッダに "_Cap" の Unicode 文字列を含めます。
  Response:
    length ヘッダと end of body ヘッダが返されます。
    length ヘッダは end of body に含まれるデータ長を示し、通常は 8 です。
    end of body はネットワークバイト順の 4 バイト整数が2つ入り、1つ目が総容量、2つ目が使用済み容量です。

Model
  モデル情報を取得します。

  Request:
    0x83 (get) opcode を使い、name ヘッダに "_Model" の Unicode 文字列を含めます。
  Response:
    length ヘッダと end of body ヘッダが返されます。
    end of body にはモデル情報を含む2つのヌル終端文字列が入ります。現状、最初の文字列は全モデルで同じようです。

List
  カレントパスのディレクトリ情報を返します。

  Request:
    0x83 (get) opcode を使い、name ヘッダに "_List" の Unicode 文字列を含めます。
  Response:
    length ヘッダと end of body ヘッダが返されます。
    end of body にはディレクトリ情報が配列形式で入り、以下の構造が繰り返されます。

    struct directory_entry {
        uint16_t size;  // 構造体の大きさ
        uint8_t  flags; // file = 0, directory = 1, unicode/longname = 2
        uint8_t  name[]; // ファイル/ディレクトリ名
    }

Remove
  カレントパスからファイルを削除します。

  Request:
    0x82 (put) opcode を使い、name ヘッダに "_Remove" の Unicode 文字列を含めます。
    その後に length と end of body ヘッダが続き、end of body には削除するファイル名のヌル終端文字列が入ります。
  Response:
    追加ヘッダはありません。

  DataPlus 5 以降の端末では、Text モード時にファイル名は UTF-16 文字列です。

SdFormat
  挿入中の SD カードをフォーマットします。

  Request:
    0x82 (put) opcode を使い、name ヘッダに "_SdFormat" の Unicode 文字列を含めます。
    その後に length と end of body ヘッダが続き、end of body はヌル文字のみを含みます。
  Response:
    追加ヘッダはありません。

Send file
  ファイルを辞書に送信します。

  Request:
    0x82 (put) opcode を使い、name, length, body/end of body ヘッダを含めます。
    name ヘッダは送信するファイル名（Unicode）、length ヘッダはファイル全体のサイズ、
    body/end of body ヘッダにファイルデータが入ります。

    ファイルが最大パケットサイズを超える場合は複数の put リクエストに分割され、
    最初のリクエストのみ name と length ヘッダを含みます。
  Response:
    追加ヘッダはありません。

Get file
  ファイルを辞書から取得します。

  Request:
    0x83 (get) opcode を使い、name ヘッダに取得するファイル名（Unicode）を含めます。
  Response:
    length ヘッダと body/end of body ヘッダが返されます。
    length ヘッダは body に含まれるデータ長を示します。body/end of body ヘッダにファイルデータが入ります。

    ファイルが大きい場合（約4KB 以上）は複数のレスポンスに分割され、最初のレスポンスのみ length ヘッダを含みます。


AuthChallenge
  辞書へ認証リクエストを送ります。

  このコマンドは Library モードで実行する必要があります。delete, upload, capacity 等の多くのコマンドは認証が必要です。
  興味深いことに、List コマンドは認証不要で、実行すると他の認証が必要なコマンドが
  まるで AuthChallenge 成功後の状態のように動作することがあります。

  Request:
    0x82 (put) opcode を使い、name ヘッダに "_AuthChallenge" の Unicode 文字列を含めます。
    その後に length と end of body ヘッダが続き、length は常に 20、end of body は 20 バイトの認証キーを含みます。
  Response:
    追加ヘッダはありません。

AuthInfo
  authinfo.inf に保存された認証情報をリセットします。

  このコマンド実行時にデバイス上のインストール済み辞書はすべて削除されます。

  Request:
    0x83 (get) opcode を使い、name ヘッダに "_AuthInfo" の Unicode 文字列を含めます。
    その後に 40 バイトの非標準ヘッダ (0x70) が続き、これは新しい authkey を生成するためのデータです。
  Response:
    length ヘッダと end of body ヘッダが返されます。length は常に 20 で、end of body に新しい 20 バイトの authkey が入ります。

UserId
  辞書のユーザーID を設定します。

  Request:
    0x82 (put) opcode を使い、name ヘッダに "_UserId" の Unicode 文字列を含めます。
    その後に length と end of body ヘッダが続き、length は常に 17、end of body には
    ヌルパディングされた 17 バイトのユーザ名が入ります。
  Response:
    追加ヘッダはありません。

Unlock
  アドオンの追加/削除を行うためにデバイスを Unlock します。

  Request:
    0x82 (put) opcode を使い、name ヘッダに "_Unlock" の Unicode 文字列を含めます。
    その後に length と end of body ヘッダが続き、length は常に 1、end of body はヌル1バイトが入ります。
  Response:
    追加ヘッダはありません。

Lock
  アドオンの追加/削除の後にデバイスを Lock します。

  Request:
    0x82 (put) opcode を使い、name ヘッダに "_Lock" の Unicode 文字列を含めます。
    その後に length と end of body ヘッダが続き、length は常に 1、end of body はヌル1バイトが入ります。
  Response:
    追加ヘッダはありません。

CName
  アドオン辞書の名前を指定します。

  Unlock の直後に送る必要があります。

  Request:
    0x82 (put) opcode を使い、name ヘッダに "_CName" の Unicode 文字列を含めます。
    その後に length と end of body ヘッダが続き、end of body には SJIS エンコードの
    ヌル終端文字列が2つ入ります。最初は5文字のアドオン ID、2つ目がアドオン辞書名です。
  Response:
    追加ヘッダはありません。

CryptKey
  新しい CryptKey を生成します。

  返されるキーは直接辞書を暗号化する鍵ではなく、実際の暗号化に使う二次鍵を生成するために使われます。

  Request:
    0x83 (get) opcode を使い、name ヘッダに "_CryptKey" の Unicode 文字列を含めます。
    その後に非標準ヘッダ (0x71) が続き、28 バイトのブロックが鍵生成に使われます。

    16 バイト鍵の生成アルゴリズムは次のように見えます:
         b[0] b[1] b[2]  b[3]  b[4]  b[5]  b[6]  b[7]  b[8]  b[9]  b[10] b[11]
      +    0    0  b[16] b[17] b[18] b[19] b[20] b[21] b[22] b[23]    0     0

    最後の4バイトは b[24] - b[27] ですが、レスポンスヘッダに返されるのは最初の 12 バイトのみです。
  Response:
    length ヘッダと end of body ヘッダが返されます。length は常に 12 で、end of body に生成された鍵の最初の 12 バイトが入ります。

